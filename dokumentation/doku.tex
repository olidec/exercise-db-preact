% Im header stehen die Grundeinstellungen des Dokuments
\documentclass[12pt,a4paper]{article} % 12 Punkte Schrift, A4 Papier
\usepackage[utf8]{inputenc} 
\usepackage[ngerman]{babel} % Passt alle automatischen Texte an. 
%\usepackage[english]{babel} % Diese Variante verwenden, fall man eine Arbeit auf Englisch schreibt.

\parindent=0cm
\parskip=0.3cm
\linespread{1.5}




% Ein paar standard Pakete. Man muss genau wissen, wofür alle gebraucht werden...
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{datetime}

%Code
\usepackage{listings}


% Informationen für die Titelseite
\title{GymInf Thesis: Webapp für Matheaufgaben}
\date{\today}
\author{Oliver de Capitani, Patrick Weber}




% Der Anfang des Dokuments
\begin{document}



\maketitle % Hier wird die Titelseite mit den obigen Informationen eingefügt. Falls man eine "kunstvollere" Titelseite mit einem anderen Programm erstellen möchte, kann man sie hier einfügen. Dafür muss man die Titelseite im gleichen Verzeichnis (z.B. mit dem Namen TitelseiteMA2016.pdf) im pdf Format ablegen und mit dem Befehl
% \includepdf{TitelseiteMA2016}
% wird sie dann eingefügt.



\newpage % Eine neue Seite wird begonnen...
\tableofcontents % Hier wird automatisch das Inhaltsverzeichnis eingefügt. Achtung: Änderungen werden erst nach dem zweiten kompilieren sichtbar.




\newpage



% Die Grundstruktur einer Arbeit:
\section{Vorwort}
Im Rahmen unseres GymInf-Projekts haben wir uns entschieden, eine Webanwendung für Mathematikaufgaben zu entwickeln. Besonders möchten wir unserem Betreuer Urs Meyer danken, der uns durch wertvolle Ratschläge und Unterstützung geholfen hat, dieses Projekt erfolgreich umzusetzen.

Die Wahl dieses Themas basiert auf dem Interesse die Frontend und Backend Applikationsentwicklung besser kennenzulernen und um auch Ideen für unseren Informatikunterricht zu sammeln, wie z.B:

Projektbasierter Unterricht: Die Schüler können ein echtes Projekt umsetzen, z.B. eine einfache Webanwendung, die sie von Grund auf entwickeln. Dies könnte ein Online-Quiz, ein kleiner Blog oder eine To-Do-Liste sein.

Einführung in Web-Technologien: Die Schüler können grundlegende Web-Technologien (HTML/CSS/JavaScript) im Unterricht kennen lernen, mit denen Sie einfache Webseiten erstellen und gestalten können. Fortgeschrittene Schüler könne auch mit Frameworks wie React/Preact/Svelte arbeiten, um moderne Webanwendungen zu entwickeln.

Datenbanken: Grundlagen von Datenbanken, sowohl relationale (SQL) als auch nicht-relationale (NoSQL), können den Schülern aufgezeigt werden und wie diese in Webanwendungen integriert werden.

API-Design und -Nutzung: Das Konzept von APIs und wie es zur Kommunikation zwischen Frontend und Backend verwendet wird kann den Schülern aufgezeigt werden. Die Schüler können einfache APIs erstellen und verwenden.

Sicherheitsaspekte in der Webentwicklung: Grundlagen der Web-Sicherheit, wie Authentifizierung, Autorisierung können den Schülern vermittelt werden.

Fächerübergreifende Projekte: Die Schüler können Webanwendungen entwickeln die schulische Konzepte veranschaulichen können, wie z.B. mathematische Probleme lösen oder biologische Daten verarbeiten.

Des Weiteren haben wir bisher als Mathematik-Lehrpersonen keinen «offiziellen» Austausch an Mathematik Aufgaben ausserhalb der verschiedenen Schulstandorte. Die Aufgaben-Datenbank soll dazu beitragen, dass Lehrpersonen Zugang zu einer umfangreicheren Sammlung an Mathematik Aufgaben haben können. Im Speziellen wäre es für Mathematik Lehrpersonen sehr hilfreich sich über Matura Aufgaben der verschiedenen Schulstandorte einen Überblick zu verschaffen, damit die Schüler mit hilfreichen Aufgaben sich optimal auf die Matura vorbereiten können.



\section{Einleitung}
Die Entwicklung einer Webanwendung für Mathematikaufgaben ist angesichts der zunehmenden Digitalisierung des Bildungswesens von Relevanz, da das Teilen und Bereitstellen von guten, lernreichen Aufgaben für die Qualität des Mathematik Unterrichts unabdingbar ist. Diese Arbeit zielt darauf ab, Mathematiklehrern eine effiziente Möglichkeit zu bieten, Aufgaben für den Unterricht zu finden und zu verwalten.


Mathematikaufgaben sollen über eine benutzerfreundliche Eingabemaske kategorisiert und unterkategorisiert in die Datenbank eingegeben werden können. Diese Aufgaben müssen nicht nur leicht erstellbar sein, sondern auch problemlos nachträglich bearbeitet oder gelöscht werden können. Besonders wichtig war uns, dass die Formeln direkt im LaTeX-Format eingegeben werden, um eine präzise und standardisierte Darstellung mathematischer Ausdrücke zu gewährleisten. Zudem sollen die erstellten Aufgaben im LaTeX-Format heruntergeladen werden können, um sie nahtlos in bestehende Lehrmaterialien integrieren zu können. Als Mathematiklehrer möchte ich die Möglichkeit haben, eine umfangreiche Sammlung von Mathematikaufgaben gezielt zu durchsuchen und daraus didaktisch sinnvolle Aufgabenblätter für meine Klassen effizient zusammenzustellen.

Unsere Forschungsfrage lautet: 

Wie kann eine Webanwendung entwickelt werden, die den Bedürfnissen von Mathematiklehrern gerecht wird, indem sie eine benutzerfreundliche und funktionsreiche Plattform bereitstellt?

Kernfunktionen dieser Webapplikation sind:

• Aufgaben erstellen: Lehrer können neue Mathematikaufgaben zur Datenbank
hinzufügen.

• Aufgaben durchsuchen: Lehrer können vorhandene Aufgaben nach verschiedenen Kriterien durchsuchen.

• Aufgaben kommentieren: Nutzer können Kommentare zu Aufgaben hinterlassen, um Feedback oder Lösungsvorschläge zu geben.

• Aufgaben verwalten: Lehrer können ihre erstellten Aufgaben bearbeiten oder löschen.

• Warenkorb für Aufgaben: Lehrer können ausgewählte Aufgaben in einem Warenkorb sammeln, um sie später in ein Aufgabenblatt zu integrieren.

In dieser Arbeit werden wir die Ziele des Projekts definieren, die gewählten Methoden erläutern und die wichtigsten Ergebnisse präsentieren. 


\section{Theoretischer Hintergrund}
\subsection{Allgemeines}
Die Digitalisierung hat das Bildungswesen grundlegend transformiert, insbesondere durch den Einsatz von E-Learning-Plattformen und digitalen Hilfsmitteln. In der Fachliteratur finden sich zahlreiche Ansätze zur Entwicklung von Webanwendungen, die den Unterricht effizienter gestalten sollen. Um dieses Ziel zu erreichen, haben wir uns für den Einsatz moderner und bewährter Web-Technologien entschieden.

Preact wurde als unsere bevorzugte Frontend-Bibliothek ausgewählt, da es eine leichtgewichtige und performante Alternative zu React darstellt. Preact ermöglicht uns die Entwicklung interaktiver Benutzeroberflächen, die eine reibungslose und schnelle Benutzererfahrung gewährleisten. Die Bibliothek bietet die Möglichkeit, wiederverwendbare Komponenten zu erstellen, was die Entwicklung und Wartung der Benutzeroberfläche erheblich vereinfacht.

Für das Backend haben wir Express gewählt, ein minimalistisch und flexibel gestaltetes Framework für Node.js. Express bietet eine robuste Basis für die Entwicklung von serverseitiger Logik und API-Routen. Es ermöglicht uns, HTTP-Anfragen effizient zu verarbeiten, Daten sicher zu speichern und verschiedene Authentifizierungsmechanismen zu implementieren. Dank der modularen Struktur von Express konnten wir eine skalierbare Backend-Architektur entwickeln, die sowohl leistungsfähig als auch leicht zu erweitern ist.

Die Datenbankinteraktion wird durch Prisma gesteuert, ein modernes ORM (Object-Relational Mapping) Tool, das eine einfache und typsichere Datenbankanbindung ermöglicht. Prisma erlaubt es uns, die Datenbankabfragen direkt in TypeScript zu schreiben, was die Konsistenz und Sicherheit des Codes erhöht. Es unterstützt Migrationen, wodurch das Datenbankschema während der Entwicklung problemlos angepasst werden kann, und ermöglicht eine effiziente Verwaltung der Datenmodelle.

Unsere Hypothese lautet, dass durch die gezielte Auswahl und Kombination dieser Technologien – Preact, Express und Prisma – eine leistungsstarke, skalierbare, benutzerfreundliche und effiziente Webanwendung entwickelt werden kann, die den Anforderungen von Mathematiklehrern gerecht wird.

\subsection{Das Architekturdesign}

\subsubsection{Backend-Architektur:} 

Für die Entwicklung des Backends haben wir uns bewusst für die Implementierung einer RESTful API entschieden. Diese Architektur bietet eine hohe Flexibilität und ist durch ihre breite Akzeptanz und Standardisierung besonders gut geeignet, um unterschiedliche Anforderungen effizient zu erfüllen. Durch die Nutzung von HTTP-Methoden wie GET, POST, PUT und DELETE können wir Ressourcen auf einfache Weise manipulieren, was die Interaktion zwischen dem Frontend und der Datenbank erheblich vereinfacht. Mit Express als unserem Backend-Framework konnten wir die API-Routen schnell und modular aufbauen, wodurch eine robuste und skalierbare Backend-Struktur entstanden ist.

\subsubsection{Frontend-Architektur:} 

Im Frontend haben wir uns auf eine klare Trennung der Komponentenstruktur konzentriert. Die Komponentenhierarchie ist so gestaltet, dass atomare und molekulare UI-Komponenten (kleinere, wiederverwendbare Bausteine) von Seitenkomponenten (größere, zusammengesetzte Einheiten) getrennt sind, die den Anwendungsfluss steuern. Diese Trennung ermöglicht eine saubere und wartbare Codebasis, in der Änderungen an einer Komponente nicht ungewollt andere Teile der Anwendung beeinflussen.

\subsubsection{Zustandsmanagement:} 

Ein effektives Zustandsmanagement ist entscheidend für die Verwaltung der Anwendungsdaten sowie der verschiedenen UI-Zustände, wie Benutzereingaben oder geladene Daten (Aufgaben). Preact bietet uns hierfür mehrere Optionen: Für lokale Zustände innerhalb einzelner Komponenten nutzen wir die useState und useEffect Hooks, die eine einfache und reaktive Verwaltung dieser Zustände ermöglichen. 
Der useState Hook ermöglicht es, Zustände innerhalb einer Funktionskomponente zu verwalten. Wenn man useState aufruft, erhält man ein Array mit zwei Werten: den aktuellen Zustand und eine Funktion, um diesen Zustand zu aktualisieren.

const [state, setState] = useState(initialValue);

-	state: Der aktuelle Zustand, den man verwenden kann.

-	setState: Eine Funktion, mit der man den Zustand ändern können.

-	initialValue: Der Anfangswert des Zustands.

Der useEffect Hook wird verwendet, um Seiteneffekte in Funktionskomponenten zu behandeln. Ein Seiteneffekt ist z.B. das Abrufen von Daten von einem Server, das Managen von Timern oder das Ändern des DOM.

Zusätzlich bietet Preact die Möglichkeit, Signals zu verwenden, die eine noch feinere Kontrolle über den reaktiven Datenfluss bieten.

Signals sind eine leistungsstarke Ergänzung zu den traditionellen Hooks wie useState und useEffect in Preact. Sie sind reaktive Zustandscontainer, die es ermöglichen, Zustandsänderungen automatisch zu verfolgen und Komponenten effizient zu aktualisieren.

Die Folgenden Beispiel beziehen sich auf die Seite um Aufgaben nach Kategorien und Subkategorien durch clicken auf dieselben zu suchen.


\begin{lstlisting}[language=Python]

const cat = signal([]);
const loadCat = async () => {
  const res = await askServer("/api/cat/", "GET");

  cat.value = res.response;
};

\end{lstlisting}

Das Signal cat wird verwendet um ale Kategorien vom Server zu laden.

\begin{lstlisting}[language=Python]

const [categories, setCategories] = useState([]);
useEffect(() => {
    const fetchCategories = async () => {
      await loadCat();
      ;
    };
    fetchCategories();
  }, []);

\end{lstlisting}


Nun wird useEffect() verwendet damit beim laden der Seite die loadCat()-Funktion die Kategorien vom Server lädt und in das array categories schreibt (setCategories(cat.value)) . Da sich diese Variable beim laden der Seite verändern könnte wird sie als useState Variable definiert.

\begin{lstlisting}[language=Python]
const [selectedCategory, setSelectedCategory] = useState("");
const [subcategories, setSubcategories] = useState([]);
  
useEffect(() => {
    if (selectedCategory) {
      const category = categories.find((c) => c.name === selectedCategory);
      setSubcategories(category ? category.subcategories : []);
    } else {
      setSubcategories([]);
    }
  }, [selectedCategory, categories]);
      
\end{lstlisting}


useEffect() für Unterkategorien: Diese Funktion wird aufgerufen, wenn selectedCategory oder categories sich ändern. Sie sucht die Unterkategorien der ausgewählten Kategorie und speichert diese in subcategories.



Für komplexere Szenarien, in denen ein globaler Zustand erforderlich ist – also Daten, die von mehreren Komponenten gleichzeitig genutzt werden – greifen wir auf die useContext API zurück. Diese ermöglicht es, einen globalen Zustand zu schaffen, der von verschiedenen Teilen der Anwendung gemeinsam genutzt werden kann, ohne dass der Code unnötig kompliziert wird. Mit useContext können wir eine zentrale Datenquelle erstellen, die es verschiedenen Komponenten ermöglicht, auf dieselben Daten oder Funktionen zuzugreifen und diese zu aktualisieren, was die Anwendung sowohl leistungsfähig als auch flexibel macht und eine reibungslose und intuitive Benutzererfahrung unterstützt.


\begin{lstlisting}[language=Python]
  const { showNotification, setCartSearch, searchText, categor } =
    useContext(SearchContext);
 \end{lstlisting}  
    
Die Variablen showNotification, setCartSearch, searchText, categor werden als Signals und im LocalStorage gespeichert, weil sie über verschiedene Komponenten hinweg geteilt werden müssen

setCartSearch speichert die Suchresultate, searchText speichert die Texteingabe nach der gesucht wird, cetegor speichert die angeclickten Kategorie und Subkategorien, und showNotification speichert die jeweiligen Fehlermeldungen beim Editieren, Eingeben oder Suchen der Aufgaben.


\begin{lstlisting}[language=Python]
const onCategoryClick = async (categoryName) => {
setSelectedCategory(categoryName);
setSelectedSubcategory(""); // Reset subcategory when selecting a new category
    
const route = `/api/ex?cat=${categoryName}`;
const res = await askServer(route, "GET");
const excat = res.response;
    
\end{lstlisting}


onCategoryClick: Diese Funktion wird aufgerufen, wenn eine Kategorie angeklickt wird. Sie setzt die ausgewählte Kategorie und setzt die Unterkategorie zurück. Dann sendet sie eine Anfrage an den Server, um Übungen basierend auf der Kategorie zu laden.


\begin{lstlisting}[language=Python]
    if (res.status != 200 || excat.length === 0) {
      showNotification("No exercise matches the search term.", "red");
      setCartSearch([]);
      setSelectedCategory("");
      searchText.value = "";
      categor.value[0] = categoryName;
      categor.value[1] = "";
    } else {
      setCartSearch(excat);
      searchText.value = "";
      categor.value[0] = categoryName;
      categor.value[1] = "";
    }
  };


\end{lstlisting}
Verarbeiten der Antwort: Wenn die Serverantwort keinen Erfolg bringt (Status nicht 200) oder keine Übungen zurückgibt, wird eine Benachrichtigung angezeigt und die Kategorieauswahl zurückgesetzt. Andernfalls wird die Liste der gefundenen Übungen gespeichert.


\begin{lstlisting}[language=Python]
  const onSubcategoryClick = async (subcategoryName) => {
    setSelectedSubcategory(subcategoryName);

    const route = `/api/ex?cat=${selectedCategory}&subcat=${subcategoryName}`;
    const res = await askServer(route, "GET");
    const exsubcat = res.response;
    
    
\end{lstlisting}

onSubcategoryClick: Diese Funktion wird aufgerufen, wenn eine Unterkategorie ausgewählt wird. Sie sendet eine Anfrage an den Server, um Übungen basierend auf der ausgewählten Unterkategorie zu laden.

\begin{lstlisting}[language=Python]

    if (res.status != 200 || exsubcat.length === 0) {
      showNotification("No exercise matches the search term.", "red");
      setCartSearch([]);
      searchText.value = "";
      categor.value[1] = subcategoryName;
    } else {
      setCartSearch(exsubcat);
      searchText.value = "";
      categor.value[1] = subcategoryName;
    }
  };
\end{lstlisting}

Verarbeiten der Antwort: Ähnlich wie bei der Kategorieauswahl wird eine Benachrichtigung angezeigt und die Unterkategorieauswahl zurückgesetzt, wenn keine passenden Übungen gefunden werden. Ansonsten wird die Liste der Übungen aktualisiert.


\subsubsection{Vergleich: Signals vs. useState/useEffect} 
\subsubsection{ Reaktivität}

•	useState/useEffect:

o	useState verwaltet den Zustand, und useEffect behandelt Seiteneffekte basierend auf Zustandsänderungen.

o	Man muss explizit Hooks verwenden, um auf Zustandsänderungen zu reagieren.

•	Signals:

o	Signals bieten eine automatische Reaktivität. Komponenten, die ein Signal lesen, werden automatisch neu gerendert, wenn sich das Signal ändert.

o	Keine Notwendigkeit für separate useEffect-Hooks, um auf einfache Zustandsänderungen zu reagieren.


Leistung

•	useState/useEffect:

o	Können zu übermäßigen Neurenderings führen, insbesondere wenn viele Zustandsänderungen und abhängige Effekte vorhanden sind.

•	Signals:

o	Feinkörnige Reaktivität ermöglicht gezieltere Updates, was die Leistung verbessern kann, da nur die betroffenen Teile der UI aktualisiert werden.


Komplexität

•	useState/useEffect:

o	Kann komplex werden, wenn viele Zustände und Effekte verwaltet werden müssen.

o	Erfordert oft das Aufteilen von Logik in mehrere Hooks.

•	Signals:

o	Einfachere und direktere Zustandsverwaltung.

o	Weniger Boilerplate-Code und klarere Zustandsabhängigkeiten.



Für komplexere Szenarien, in denen ein globaler Zustand erforderlich ist – also Daten, die von mehreren Komponenten gleichzeitig genutzt werden – greifen wir auf die useContext API zurück. Diese ermöglicht es, einen globalen Zustand zu schaffen, der von verschiedenen Teilen der Anwendung gemeinsam genutzt werden kann, ohne dass der Code unnötig kompliziert wird. Mit useContext können wir eine zentrale Datenquelle erstellen, die es verschiedenen Komponenten ermöglicht, auf dieselben Daten oder Funktionen zuzugreifen und diese zu aktualisieren, was die Anwendung sowohl leistungsfähig als auch flexibel macht und eine reibungslose und intuitive Benutzererfahrung unterstützt.


Bsp aus App:

\subsection{Die Datenmodellierung}

Die Applikation nutzt ein relationales Datenmodell mit folgenden Hauptentitäten:

•	Benutzer (Users)

o	Attribute: BenutzerID, Name, Email, Passwort, Rolle

o	Beziehungen: 1: n zu Aufgaben, 1: n zu Kommentaren

•	Aufgaben (Exercises)

o	Attribute: AufgabenID, Titel, Inhalt, Zusammenfassung, Lösung, Erstellungsdatum, Update-Datum, AutorID

o	Beziehungen: n:1 zu Benutzer, n:1 zu Kategorien, n:1 zu Subkategorien

•	Kategorien (Categories)

o	Attribute: KategorieID, Name, Beschreibung

o	Beziehungen: 1:n zu Aufgaben, 1: n zu Subkategorien

•	Subkategorien (Subcategories)

o	Attribute: SubkategorieID, Name, Beschreibung, KategorieID

o	Beziehungen: n:1 zu Kategorie, 1:n zu Aufgaben

•	Kommentare (Comments)

o	Attribute: KommentarID, Inhalt, Erstellungsdatum, BenutzerID, AufgabenID

o	Beziehungen: n:1 zu Benutzer, n:1 zu Aufgaben


Die Datenbankstruktur unterstützt umfassende Interaktionen zwischen Benutzern, ihren Aufgaben und Kommentaren sowie die Kategorisierung von Aufgaben.


\section{Methodik}
Unser Projekt folgte einem strukturierten Softwareentwicklungsprozess, der in mehrere Phasen unterteilt war. Wir begannen mit einer detaillierten Anforderungsanalyse und der Definition von Use Cases, um die Bedürfnisse der Endbenutzer zu verstehen.

\subsection{Backend-Entwicklung}
Die Implementierung von CRUD-Operationen und Authentifizierungssystemen stellte sicher, dass die Anwendung sicher und robust ist.

CRUD- und HTTP-Operationen:

CRUD steht für Create, Read, Update, Delete und bezieht sich auf die vier grundlegenden Operationen, die in vielen Anwendungen zur Interaktion mit Datenbanken oder Datenspeichern verwendet werden. Die Implementierung von CRUD-Operationen ermöglicht es Benutzern (oder Systemen), Daten zu erstellen, abzurufen (lesen), zu aktualisieren und zu löschen.

In einer Webanwendung werden CRUD-Operationen typischerweise über das Backend realisiert, wobei das Frontend (die Benutzeroberfläche) Anfragen an das Backend sendet, um Daten zu erstellen, abzurufen, zu aktualisieren oder zu löschen. Das Backend interagiert dann mit der Datenbank, um die angeforderten Aktionen durchzuführen und das Ergebnis (z.B. die abgerufenen Daten oder eine Bestätigung der Aktion) an das Frontend zurückzusenden, wo es dem Benutzer angezeigt wird.

Für das Backend, das oft eine API bereitstellt, können diese Operationen spezifischen Endpunkten entsprechen, z.B.:

•	GET /api/users	für das Abrufen von Benutzern (Read)

•	POST /api/user	für das Erstellen eines neuen Benutzers (Create)

•	PUT /api/user	für das Aktualisieren eines spezifischen Benutzers (Update)

•	POST /api/ex	für das Erstellen einer neuen Aufgabe (Create)

•	GET /api/ex	für das Abrufen von Aufgaben (Read)

•	PUT /api/ex/:id	für das Aktualisieren einer spezifischen Aufgabe (Update)

•	DELETE /api/ex/:id 	für das Löschen einer Aufgabe (Delete)

•	GET /api/ex/search/:serachText	für das Abrufen von Aufgaben nach Suchbegriffen (Read)

•	GET /api/ex/category/:category	für das Abrufen von Aufgaben nach Kategorien (Read)

•	GET /api/ex/:id	für das Abrufen einer spezifischen Aufgabe (Read)

•	POST /api/download/ 	für das Herunterladen der spezifischen Aufgabe im Warenkorb (Download)


\subsection{Frontend-Entwicklung}
Wir entwickelten mehrere UI-Komponenten, die es den Nutzern ermöglichen, Aufgaben einfach zu erstellen, zu durchsuchen und zu verwalten.
\subsection{Authentifizierug und Autorisierung}
Argon2 nimmt als Eingabe das Passwort des Benutzers, einen Salz (eine zufällig generierte Zeichenfolge, die jedem Passwort-Hash hinzugefügt wird, um die Einzigartigkeit zu gewährleisten), und mehrere Parameter, die die Komplexität des Hashing-Vorgangs steuern (wie Speicherbedarf, Rechenzeit und Parallelität).Basierend auf diesen Eingaben führt Argon2 eine Reihe von komplexen, rechenintensiven Operationen durch. Diese Operationen sind so gestaltet, dass sie sowohl eine hohe Menge an CPU-Ressourcen als auch Speicher benötigen. Dies macht es sehr schwierig für Angreifer, Passwörter zu erraten oder Brute-Force-Angriffe durchzuführen, selbst wenn sie über leistungsfähige Hardware verfügen.

Das Ergebnis des Prozesses ist ein Passwort-Hash, der in der Datenbank gespeichert wird. Da der gleiche Prozess (mit dem gleichen Salz und denselben Parametern) immer denselben Hash erzeugt, kann das System das vom Benutzer bei der Anmeldung eingegebene Passwort überprüfen, ohne das eigentliche Passwort kennen oder speichern zu müssen. Sicherheit gegen Brute-Force-Angriffe: Die rechen- und speicherintensive Natur von Argon2 macht es teuer und zeitaufwändig, Hashes zu knacken. Dies schützt gegen Angriffe, die darauf abzielen, Passwörter durch Ausprobieren vieler möglicher Kombinationen (Brute-Force) zu erraten.

\subsection{Testing und Qualitätssicherung: }
Wir führten umfangreiche Tests durch, einschließlich Unit-Tests und Benutzerakzeptanztests, um sicherzustellen, dass die Anwendung den Erwartungen entspricht.


\subsection{Deployment und Inbetriebnahme: }
Nach Abschluss der Entwicklungsarbeiten wurde die Anwendung auf einer geeigneten Hosting-Plattform bereitgestellt und auf ihre Funktionalität in der Produktionsumgebung überprüft.


\section{Ergbenisse}
\subsection{Allgemeines}

Die entwickelte Webanwendung bietet Mathematiklehrern eine Plattform, auf der sie Aufgaben erstellen, durchsuchen, kommentieren und verwalten können. Zu den wichtigsten Funktionen gehören:

•	Aufgaben erstellen und verwalten: Lehrer können neue Aufgaben zur Datenbank hinzufügen und bestehende Aufgaben bearbeiten oder löschen.

•	Aufgabensuche: Die Suchfunktion ermöglicht es den Nutzern, spezifische Aufgaben nach Stichworten oder Kategorien zu finden.

•	Warenkorbsystem: Lehrer können ausgewählte Aufgaben in einem Warenkorb sammeln und daraus Aufgabenblätter erstellen.

Die Anwendung wurde erfolgreich implementiert und erfüllt die gestellten Anforderungen.

\subsection{Die Komponentenübersicht}

•	Aufgabendetails (Exercise Details):

Eine Detailansicht (AufgDetails) für jede Aufgabe, die Informationen wie Aufgabentext, Lösung, Kommentare und Kategoriezugehörigkeit enthält. Benutzer können Aufgaben kommentieren und in den Warenkorb legen.

•	Suchergebnisse (Search Results):

Komponenten für die Anzeige von Suchergebnissen, einschließlich Suchkarten (SearchCard), die einzelne Aufgaben darstellen, und einer Listenansicht (CardListSearch), die eine Sammlung von Suchkarten enthält. Ein spezieller Warenkorb für die Suche (SearchKorb) sammelt gesuchte Aufgaben für spätere Aktionen.

•	Warenkorb (Warenkorb):

Beinhaltet Komponenten zum Verwalten der ausgewählten Aufgaben, wie WarenCard für einzelne Aufgaben im Warenkorb und CardListWaren für die Gesamtansicht des Warenkorbs. Der WarenKorb selbst ist die Hauptkomponente, die den Nutzern die Interaktion mit dem Warenkorb ermöglicht, einschließlich der Überprüfung und Finalisierung ihrer Auswahl.

•	Aufgaben hinzufügen (Add Exercises):

Die ExForm-Komponente ermöglicht das Erstellen neuer Aufgaben. Sie umfasst Formularfelder für die Eingabe von Titel, Inhalt, Lösung und optionalen Kategorien. Über eine API-Anfrage (askServer(/api/ex, "POST", ex)) werden die Daten an das Backend gesendet und die Aufgabe wird der Datenbank hinzugefügt.

•	Aufgaben finden (Find Exercises):

Dieser Bereich umfasst mehrere Komponenten, die unterschiedliche Methoden zur Aufgabensuche anbieten, darunter FindExByCategory für kategoriebasierte Suche, FindExByIdFromServer für die direkte Abfrage einer Aufgabe über ihre ID und FindExBySearchText für textbasierte Suchanfragen.

•	Benutzerregistrierung und -anmeldung (User Registration/Login):

Eine Form-Komponente unterstützt die Registrierung neuer Benutzer und die Anmeldung bestehender Benutzer durch Übermittlung ihrer Anmeldeinformationen an das Backend (askServer(/api/user, "POST", user)). Authentifizierungsdaten werden überprüft, um Zugang zu geschützten Bereichen der Anwendung zu gewähren.

•	Navigation (Navigation):

Die Menu-Komponente stellt die Hauptnavigation der Anwendung bereit und ermöglicht den Zugriff auf die verschiedenen Seiten und Funktionen der App, darunter die Startseite (/), das Hinzufügen von Aufgaben (/add), das Finden von Aufgaben (/find), den Warenkorb (/warenkorb) und die Detailansicht einer spezifischen Aufgabe (/:id).

•	Seiten (Pages):

Definiert die Struktur der Anwendung und beinhaltet Seitenkomponenten wie User für die Benutzerregistrierung und -anmeldung, AddExercise für das Hinzufügen neuer Aufgaben, FindExercise für die Aufgabensuche, Letzte Suchresultate für das Anzeigen der zuletzt gesuchten Aufgaben und WarenKorb für die Ansicht und Verwaltung des Warenkorbs.




\section{Fazit/Diskussion}
Unsere Untersuchung hat gezeigt, dass die gewählten Technologien geeignet waren, um eine benutzerfreundliche und effiziente Webanwendung zu entwickeln. Die Hypothese, dass eine solche Anwendung den Bedürfnissen von Mathematiklehrern gerecht wird, konnte bestätigt werden. Allerdings stießen wir auf einige Herausforderungen, insbesondere im Bereich der Performance-Optimierung und der Benutzerfreundlichkeit, die in zukünftigen Projekten weiter untersucht werden sollten.

Zukünftige Arbeiten könnten sich darauf konzentrieren, die Anwendung durch zusätzliche Funktionen wie die Integration von KI-gestützten Aufgabenvorschlägen zu erweitern.

\section{Schlusswort}
Die Arbeit an diesem Projekt war eine wertvolle Erfahrung, die uns sowohl im Bereich der Softwareentwicklung als auch in der Projektorganisation weitergebracht hat. Die Erreichung unserer Ziele hat unsere Erwartungen erfüllt, und wir hoffen, dass unsere Anwendung einen praktischen Beitrag zur Verbesserung des Mathematikunterrichts leisten kann.

\newpage
   
  
% Hier beginnt der Anhang
\appendix
\section{Anhang}
\newpage





\section{Bilderverzeichnis}
\listoffigures



\newpage
\section{Literaturverzeichnis}

\begin{thebibliography}{1} % Hier werden die einzelnen Quellen abgelegt. Die Quellen werden mit dem Befehl \bibitem kreiert. Der Ausdruck in geschweiften Klammern ist die interne Bezeichnung, die man verwendet, um daraus im Text zu zitieren


\bibitem{buch1} Nachname, Vorname {\em Titel eines ersten Buchs} Jahr: Verlag.

\bibitem{buch2} Nachname, Vorname {\em Titel eines zweiten Buchs} Jahr: Verlag.

% Diese Quelle wird im Text zitiert, wenn man den Befehl \cite{sw16} eingibt.


\end{thebibliography}








\end{document}