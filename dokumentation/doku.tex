% Im header stehen die Grundeinstellungen des Dokuments
\documentclass[12pt,a4paper]{article} % 12 Punkte Schrift, A4 Papier
\usepackage[utf8]{inputenc} 
\usepackage[ngerman]{babel} % Passt alle automatischen Texte an. 
%\usepackage[english]{babel} % Diese Variante verwenden, fall man eine Arbeit auf Englisch schreibt.

\parindent=0cm
\parskip=0.3cm
\linespread{1.5}




% Ein paar standard Pakete. Man muss genau wissen, wofür alle gebraucht werden...
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{datetime}

%Code
\usepackage{listings}
\usepackage{xcolor}


\lstset{
    language=Python,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},          % Schlüsselwörter (z.B. function, if, else)
    stringstyle=\color{orange},         % Zeichenketten
    commentstyle=\color{gray},          % Kommentare
    numberstyle=\tiny\color{gray},      % Zeilennummern
    stepnumber=1,                       % Zeilennummernschritt
    numbersep=10pt,                     % Abstand zu Zeilennummern
    showspaces=false,                   % Leerzeichen nicht anzeigen
    showstringspaces=false,             % Leerzeichen in Zeichenketten nicht anzeigen
    breaklines=true,                    % Zeilenumbruch bei langen Zeilen
    frame=single,                       % Rahmen um den Code
    tabsize=2,                          % Tab-Breite
    captionpos=b,                       % Position der Beschriftung (b=unten)
    morekeywords={console, log},        % Zusätzliche Schlüsselwörter
    keywordstyle=[2]\color{purple},     % Stil für spezielle Schlüsselwörter (z.B. console, log)
    identifierstyle=\color{teal},       % Stil für Variablen und Funktionsnamen
    numberstyle=\tiny\color{gray},      % Stil für Zeilennummern
    emph={function, return, var},       % Hervorhebung spezifischer Schlüsselwörter
    emphstyle=\color{magenta},          % Stil der hervorgehobenen Wörter
    commentstyle=\color{gray}, % Stil für Kommentare (z.B. grünlich)
    literate=
    *{0}{{{\color{red}0}}}{1}           % Zahlen in Rot
     {1}{{{\color{red}1}}}{1}
     {2}{{{\color{red}2}}}{1}
     {3}{{{\color{red}3}}}{1}
     {4}{{{\color{red}4}}}{1}
     {5}{{{\color{red}5}}}{1}
     {6}{{{\color{red}6}}}{1}
     {7}{{{\color{red}7}}}{1}
     {8}{{{\color{red}8}}}{1}
     {9}{{{\color{red}9}}}{1}
     {=>}{{{\color{blue}=>}}}{2},    
     comment=[l]{//}  % Legt // als Kommentarzeichen fest   % Operatoren hervorheben
}



% Informationen für die Titelseite
\title{GymInf Thesis: Webapp für Matheaufgaben}
\date{\today}
\author{Oliver De Capitani, Patrick Weber}




% Der Anfang des Dokuments
\begin{document}



\maketitle % Hier wird die Titelseite mit den obigen Informationen eingefügt. Falls man eine "kunstvollere" Titelseite mit einem anderen Programm erstellen möchte, kann man sie hier einfügen. Dafür muss man die Titelseite im gleichen Verzeichnis (z.B. mit dem Namen TitelseiteMA2016.pdf) im pdf Format ablegen und mit dem Befehl
% \includepdf{TitelseiteMA2016}
% wird sie dann eingefügt.



\newpage % Eine neue Seite wird begonnen...
\tableofcontents % Hier wird automatisch das Inhaltsverzeichnis eingefügt. Achtung: Änderungen werden erst nach dem zweiten kompilieren sichtbar.




\newpage



% Die Grundstruktur einer Arbeit:
\section{Vorwort}


Im Rahmen unseres GymInf-Projekts haben wir uns entschieden, eine Webanwendung für Mathematikaufgaben zu entwickeln. Besonders möchten wir unserem Betreuer Urs Meyer danken, der uns durch wertvolle Ratschläge und Unterstützung geholfen hat, dieses Projekt erfolgreich umzusetzen.

Die Wahl dieses Themas basiert auf dem Interesse die Frontend und Backend Applikationsentwicklung besser kennenzulernen und um auch Ideen für unseren Informatikunterricht zu sammeln, wie z.B:

Projektbasierter Unterricht: Die Schüler können ein echtes Projekt umsetzen, z.B. eine einfache Webanwendung, die sie von Grund auf entwickeln. Dies könnte ein Online-Quiz, ein kleiner Blog oder eine To-Do-Liste sein.

Einführung in Web-Technologien: Die Schüler können grundlegende Web-Technologien (HTML/CSS/JavaScript) im Unterricht kennen lernen, mit denen Sie einfache Webseiten erstellen und gestalten können. Fortgeschrittene Schüler könne auch mit Frameworks wie React/Preact/Svelte arbeiten, um moderne Webanwendungen zu entwickeln.

Datenbanken: Grundlagen von Datenbanken, sowohl relationale (SQL) als auch nicht-relationale (NoSQL), können den Schülern aufgezeigt werden und wie diese in Webanwendungen integriert werden.

API-Design und -Nutzung: Das Konzept von APIs und wie es zur Kommunikation zwischen Frontend und Backend verwendet wird kann den Schülern aufgezeigt werden. Die Schüler können einfache APIs erstellen und verwenden.

Sicherheitsaspekte in der Webentwicklung: Grundlagen der Web-Sicherheit, wie Authentifizierung, Autorisierung können den Schülern vermittelt werden.

Fächerübergreifende Projekte: Die Schüler können Webanwendungen entwickeln die schulische Konzepte veranschaulichen können, wie z.B. mathematische Probleme lösen oder biologische Daten verarbeiten.

Des Weiteren haben wir bisher als Mathematik-Lehrpersonen keinen offiziellen Austausch an Mathematik Aufgaben ausserhalb der verschiedenen Schulstandorte. Die Aufgaben-Datenbank soll dazu beitragen, dass Lehrpersonen Zugang zu einer umfangreicheren Sammlung an Mathematik Aufgaben haben können. Im Speziellen wäre es für Mathematik Lehrpersonen sehr hilfreich sich über Matura Aufgaben der verschiedenen Schulstandorte einen Überblick zu verschaffen, damit die Schüler mit hilfreichen Aufgaben sich optimal auf die Matura vorbereiten können.



\section{Einleitung}
Die Entwicklung einer Webanwendung für Mathematikaufgaben ist angesichts der zunehmenden Digitalisierung des Bildungswesens von Relevanz, da das Teilen und Bereitstellen von guten, lernreichen Aufgaben für die Qualität des Mathematik Unterrichts unabdingbar ist. Diese Arbeit zielt darauf ab, Mathematiklehrern eine effiziente Möglichkeit zu bieten, Aufgaben für den Unterricht zu finden und zu verwalten.


Mathematikaufgaben sollen über eine benutzerfreundliche Eingabemaske kategorisiert und unterkategorisiert in die Datenbank eingegeben werden können. Diese Aufgaben müssen nicht nur leicht erstellbar sein, sondern auch problemlos nachträglich bearbeitet oder gelöscht werden können. Besonders wichtig war uns, dass die Formeln direkt im LaTeX-Format eingegeben werden, um eine präzise und standardisierte Darstellung mathematischer Ausdrücke zu gewährleisten. Zudem sollen die erstellten Aufgaben im LaTeX-Format heruntergeladen werden können, um sie nahtlos in bestehende Lehrmaterialien integrieren zu können. Als Mathematiklehrer möchte ich die Möglichkeit haben, eine umfangreiche Sammlung von Mathematikaufgaben gezielt zu durchsuchen und daraus didaktisch sinnvolle Aufgabenblätter für meine Klassen effizient zusammenzustellen.

Unsere Forschungsfrage lautet: 

Wie kann eine Webanwendung entwickelt werden, die den Bedürfnissen von Mathematiklehrern gerecht wird, indem sie eine benutzerfreundliche und funktionsreiche Plattform bereitstellt?

Kernfunktionen dieser Webapplikation sind:
\begin{itemize}



\item Aufgaben erstellen: Lehrer können neue Mathematikaufgaben zur Datenbank
hinzufügen.

\item Aufgaben durchsuchen: Lehrer können vorhandene Aufgaben nach verschiedenen Kriterien durchsuchen.

\item Aufgaben kommentieren: Nutzer können Kommentare zu Aufgaben hinterlassen, um Feedback oder Lösungsvorschläge zu geben.

\item Aufgaben verwalten: Lehrer können ihre erstellten Aufgaben bearbeiten oder löschen.

\item Warenkorb für Aufgaben: Lehrer können ausgewählte Aufgaben in einem Warenkorb sammeln, um sie später in ein Aufgabenblatt zu integrieren.
\end{itemize}

In dieser Arbeit werden wir die Ziele des Projekts definieren, die gewählten Methoden erläutern und die wichtigsten Ergebnisse präsentieren. 


\section{Theoretischer Hintergrund}
\subsection{Allgemeines}
Die Digitalisierung hat das Bildungswesen grundlegend transformiert, insbesondere durch den Einsatz von E-Learning-Plattformen und digitalen Hilfsmitteln. In der Fachliteratur finden sich zahlreiche Ansätze zur Entwicklung von Webanwendungen, die den Unterricht effizienter gestalten sollen. Um dieses Ziel zu erreichen, haben wir uns für den Einsatz moderner und bewährter Web-Technologien entschieden.

Preact wurde als unsere bevorzugte Frontend-Bibliothek ausgewählt, da es eine leichtgewichtige und performante Alternative zu React darstellt. Preact ermöglicht uns die Entwicklung interaktiver Benutzeroberflächen, die eine reibungslose und schnelle Benutzererfahrung gewährleisten. Die Bibliothek bietet die Möglichkeit, wiederverwendbare Komponenten zu erstellen, was die Entwicklung und Wartung der Benutzeroberfläche erheblich vereinfacht.

Für das Backend haben wir Express gewählt, ein minimalistisch und flexibel gestaltetes Framework für Node.js. Express bietet eine robuste Basis für die Entwicklung von serverseitiger Logik und API-Routen. Es ermöglicht uns, HTTP-Anfragen effizient zu verarbeiten, Daten sicher zu speichern und verschiedene Authentifizierungsmechanismen zu implementieren. Dank der modularen Struktur von Express konnten wir eine skalierbare Backend-Architektur entwickeln, die sowohl leistungsfähig als auch leicht zu erweitern ist.

Die Datenbankinteraktion wird durch Prisma gesteuert, ein modernes ORM (Object-Relational Mapping) Tool, das eine einfache und typsichere Datenbankanbindung ermöglicht. Prisma erlaubt es uns, die Datenbankabfragen direkt in TypeScript zu schreiben, was die Konsistenz und Sicherheit des Codes erhöht. Es unterstützt Migrationen, wodurch das Datenbankschema während der Entwicklung problemlos angepasst werden kann, und ermöglicht eine effiziente Verwaltung der Datenmodelle.

Unsere Hypothese lautet, dass durch die gezielte Auswahl und Kombination dieser Technologien – Preact, Express und Prisma – eine leistungsstarke, skalierbare, benutzerfreundliche und effiziente Webanwendung entwickelt werden kann, die den Anforderungen von Mathematiklehrern gerecht wird.

\subsection{Das Architekturdesign}

\subsubsection{Backend-Architektur:} 

Für die Entwicklung des Backends haben wir uns bewusst für die Implementierung einer RESTful API entschieden. Diese Architektur bietet eine hohe Flexibilität und ist durch ihre breite Akzeptanz und Standardisierung besonders gut geeignet, um unterschiedliche Anforderungen effizient zu erfüllen. Durch die Nutzung von HTTP-Methoden wie GET, POST, PUT und DELETE können wir Ressourcen auf einfache Weise manipulieren, was die Interaktion zwischen dem Frontend und der Datenbank erheblich vereinfacht. Mit Express als unserem Backend-Framework konnten wir die API-Routen schnell und modular aufbauen, wodurch eine robuste und skalierbare Backend-Struktur entstanden ist.

\subsubsection{Frontend-Architektur:} 

Im Frontend haben wir uns auf eine klare Trennung der Komponentenstruktur konzentriert. Die Komponentenhierarchie ist so gestaltet, dass atomare und molekulare UI-Komponenten (kleinere, wiederverwendbare Bausteine) von Seitenkomponenten (größere, zusammengesetzte Einheiten) getrennt sind, die den Anwendungsfluss steuern. Diese Trennung ermöglicht eine saubere und wartbare Codebasis, in der Änderungen an einer Komponente nicht ungewollt andere Teile der Anwendung beeinflussen.

\subsection{Zustandsmanagement}

\subsubsection{Allgemeines: useState, useEffect und Signals}

Ein effektives Zustandsmanagement ist entscheidend für die Verwaltung der Anwendungsdaten sowie der verschiedenen UI-Zustände, wie Benutzereingaben oder geladene Daten (Aufgaben). Preact bietet uns hierfür mehrere Optionen: Für lokale Zustände innerhalb einzelner Komponenten nutzen wir die useState und useEffect Hooks, die eine einfache und reaktive Verwaltung dieser Zustände ermöglichen. 
Der useState Hook ermöglicht es, Zustände innerhalb einer Funktionskomponente zu verwalten. Wenn man useState aufruft, erhält man ein Array mit zwei Werten: den aktuellen Zustand und eine Funktion, um diesen Zustand zu aktualisieren.

- \texttt{const [state, setState] = useState(initialValue);}

- \texttt{state}: Der aktuelle Zustand, den man verwenden kann.

- \texttt{setState}: Eine Funktion, mit der man den Zustand ändern können.

- \texttt{initialValue}: Der Anfangswert des Zustands.

Der useEffect Hook wird verwendet, um Seiteneffekte in Funktionskomponenten zu behandeln. Ein Seiteneffekt ist z.B. das Abrufen von Daten von einem Server, das Managen von Timern oder das Ändern des DOM.

Zusätzlich bietet Preact die Möglichkeit, Signals zu verwenden, die eine noch feinere Kontrolle über den reaktiven Datenfluss bieten.
Signals sind eine leistungsstarke Ergänzung zu den traditionellen Hooks wie useState und useEffect in Preact. Sie sind reaktive Zustandscontainer, die es ermöglichen, Zustandsänderungen automatisch zu verfolgen und Komponenten effizient zu aktualisieren. Signals bieten eine automatische Reaktivität. Komponenten, die ein Signal lesen, werden automatisch neu gerendert, wenn sich das Signal ändert.


\subsubsection{Zustandsmanagement für die Komponente FindExSubCat } 
Die Folgenden Beispiel beziehen sich auf die Seite um Aufgaben nach Kategorien und Subkategorien durch clicken auf dieselben zu suchen.

Das Signal \texttt{cat} wird verwendet um ale Kategorien vom Server zu laden.

\begin{lstlisting}
const cat = signal([]);
const loadCat = async () => {
  const res = await askServer("/api/cat/", "GET");

  cat.value = res.response;
};

\end{lstlisting}

Nun wird die useEffect()-Funktion verwendet damit beim laden der Seite die loadCat()-Funktion die Kategorien vom Server lädt und in das array categories schreibt \texttt{(setCategories(cat.value))} . Da sich diese Variable beim laden der Seite verändern könnte, wird sie als useState Variable definiert. 
Diese useEffect()-Funktion wird nur beim laden der Seite ausgeführt, da die Liste der Abhängigkeiten (leeres Array auf der letzten Zeile) leer bleibt. Diese Liste von Variablen definert, dass die useEffect()-Funktion erneut ausgeführt werden muss, sofern es eine Änderung der Variablen in diesem Array gibt.
\begin{lstlisting}

const [categories, setCategories] = useState([]);
useEffect(() => {
    const fetchCategories = async () => {
      await loadCat();
      setCategories(cat.value);
    };
    fetchCategories();
  }, []);

\end{lstlisting}


Die Funktion \texttt{onCategoryClick}: Diese Funktion wird aufgerufen, wenn eine Kategorie angeklickt wird. Sie setzt die ausgewählte Kategorie in die Variable selectedCategory und setzt das Array der Unterkategorie zurück (leere Liste). Dann sendet sie eine Anfrage an den Server, um Übungen basierend auf der Kategorie zu laden und in der Variablen excat zu speichern.

\begin{lstlisting}[language=Python]
const [selectedCategory, setSelectedCategory] = useState("");
const [selectedSubcategory, setSelectedSubcategory] = useState("");


const onCategoryClick = async (categoryName) => {
setSelectedCategory(categoryName);
setSelectedSubcategory(""); # Reset subcategory when selecting a new category
    
const route = `/api/ex?cat=${categoryName}`;
const res = await askServer(route, "GET");
const excat = res.response;
    
\end{lstlisting}

Nun wird die Antwort des Servers verarbeitet: Wenn die Serverantwort keinen Erfolg bringt (Status nicht 200) oder keine Übungen zurückgibt, wird eine Benachrichtigung angezeigt und die Kategorieauswahl zurückgesetzt. Andernfalls wird die Liste der gefundenen Übungen mit der Funktion \texttt{setCartSearch} gespeichert. (siehe useContext)


\begin{lstlisting}[language=Python]
    if (res.status != 200 || excat.length === 0) {
      showNotification("No exercise matches the search term.", "red");
      setCartSearch([]);
      setSelectedCategory("");
      searchText.value = "";
      categor.value[0] = categoryName;
      categor.value[1] = "";
    } else {
      setCartSearch(excat);
      searchText.value = "";
      categor.value[0] = categoryName;
      categor.value[1] = "";
    }
  };


\end{lstlisting}



useEffect() für Unterkategorien: Diese Funktion sucht die Unterkategorien der ausgewählten Kategorie, die in der Variablen \texttt{selectedCategory} gespeichert wurde und speichert diese im Array \texttt{subcategories} und zwar jedes Mal, wenn sich \texttt{selectedCategory} oder \texttt{categories} ändert (Seiteneffekt). Ob sich das Array categories ändert, wird nur beim ersten rendern der Seite überprüft, da bei der ersten useEffect() Funktion das Abhängigkeits- Array leer bleibt.


\begin{lstlisting}[language=Python]
const [subcategories, setSubcategories] = useState([]);
 
useEffect(() => {
    if (selectedCategory) {
      const category = categories.find((c) => c.name === selectedCategory);
      setSubcategories(category ? category.subcategories : []);
    } else {
      setSubcategories([]);
    }
  }, [selectedCategory, categories]);
      
\end{lstlisting}



Für komplexere Szenarien, in denen ein globaler Zustand erforderlich ist – also Daten, die von mehreren Komponenten gleichzeitig genutzt werden – greifen wir auf die useContext API zurück. Diese ermöglicht es, einen globalen Zustand zu schaffen, der von verschiedenen Teilen der Anwendung gemeinsam genutzt werden kann, ohne dass der Code unnötig kompliziert wird. Mit \texttt{useContext} können wir eine zentrale Datenquelle erstellen, die es verschiedenen Komponenten ermöglicht, auf dieselben Daten oder Funktionen zuzugreifen und diese zu aktualisieren, was die Anwendung sowohl leistungsfähig als auch flexibel macht und eine reibungslose und intuitive Benutzererfahrung unterstützt.


\begin{lstlisting}[language=Python]
  const { showNotification, setCartSearch, searchText, categor } =
    useContext(SearchContext);
 \end{lstlisting}  
 
Hier werden mehrere Variablen (showNotification, setCartSearch, searchText und categor) aus dem SearchContext abgerufen, die als Signals implementiert sind und im localStorage des Browsers gespeichert werden, da diese Daten zwischen verschiedenen Komponenten geteilt werden müssen.

\begin{itemize}
    \item \texttt{setCartSearch} speichert die Suchergebnisse, die von der Benutzerabfrage zurückgegeben werden.
    \item \texttt{searchText} hält den eingegebenen Suchtext, nach dem der Benutzer sucht.
    \item \texttt{categor} speichert die vom Benutzer angeklickte Kategorie und Subkategorie.
    \item \texttt{showNotification} speichert und verwaltet Benachrichtigungen oder Fehlermeldungen, die beim Bearbeiten, Eingeben oder Suchen von Aufgaben auftreten.
\end{itemize}


Die Signale für diese Variablen sind wie folgt definiert. Der SearchProvider erstellt einen Kontext mit diesen Variablen und Funktionen, der von allen untergeordneten Komponenten (Children) genutzt werden kann:
    
\begin{lstlisting}[language=Python]

export const SearchProvider = ({ children }) => {
  const cartSearch = signal(
    JSON.parse(window.localStorage.getItem("cartSearch")) || []
  );

  const categor = signal(
    JSON.parse(window.localStorage.getItem("categor")) || []
  );

  const searchText = signal(
    JSON.parse(window.localStorage.getItem("searchText"))
  );
  
  const setCartSearch = (exercises) => {
    cartSearch.value = exercises;
  };

const showNotification = (message, color) => {
    const container = document.getElementById("notification-container");
   ....// "Erstelle das Benachrichtigungselement"
   .....}
   
effect(() => {
    window.localStorage.setItem("cartSearch", 
    window.localStorage.setItem("categor", JSON.stringify(categor.value));
  });
  return (
    <SearchContext.Provider
      value={{
        categor,
        searchText,
        setCartSearch,
        cartSearch,
        showNotification,
      }}
    >
      {children}
    </SearchContext.Provider>
  );
};




 \end{lstlisting}  
Der Kontext-Provider gibt die Werte und Funktionen (\texttt{categor, setCartSearch, cartSearch, showNotification}) weiter, sodass alle untergeordneten Komponenten auf diese zugreifen können.
Mit diesem Ansatz stellen wir sicher, dass wichtige Zustandsinformationen wie Suchergebnisse, ausgewählte Kategorien und Benachrichtigungen zentral gespeichert und zwischen verschiedenen Komponenten geteilt werden können. 


Die Funktion \texttt{onSubcategoryClick}: Diese Funktion wird aufgerufen, wenn eine Unterkategorie ausgewählt wird. Sie sendet eine Anfrage an den Server, um Übungen basierend auf der ausgewählten Unterkategorie zu laden und und in der Variablen \texttt{exsubcat} zu speichern.

\begin{lstlisting}[language=Python]
  const onSubcategoryClick = async (subcategoryName) => {
    setSelectedSubcategory(subcategoryName);

    const route = `/api/ex?cat=${selectedCategory}&subcat=${subcategoryName}`;
    const res = await askServer(route, "GET");
    const exsubcat = res.response;
    
    
\end{lstlisting}

Verarbeiten der Server-Antwort: Ähnlich wie bei der Kategorieauswahl wird eine Benachrichtigung angezeigt und die Unterkategorieauswahl zurückgesetzt, wenn keine passenden Übungen gefunden werden. Ansonsten wird die Liste der Übungen mit der Funktion \texttt{setCartSearch} gespeichert. (siehe useContext API).


\begin{lstlisting}[language=Python]

    if (res.status != 200 || exsubcat.length === 0) {
      showNotification("No exercise matches the search term.", "red");
      setCartSearch([]);
      searchText.value = "";
      categor.value[1] = subcategoryName;
    } else {
      setCartSearch(exsubcat);
      searchText.value = "";
      categor.value[1] = subcategoryName;
    }
  };
\end{lstlisting}


\subsection{Datenbankmodell}

\subsubsection{Datenbanktabellen}

In diesem Abschnitt wird das Datenbankmodell beschrieben, welches für die Speicherung der Benutzerinformationen, Aufgaben und deren Kategorisierung verwendet wird. Die Implementierung erfolgt mit Prisma ORM und PostgreSQL als Datenbank. Im Folgenden wird die Struktur der relevanten Tabellen dokumentiert.

Das Datenbankmodell umfasst vier Haupttabellen: \texttt{User}, \texttt{Exercise}, \texttt{Category} und \texttt{Subcategory}. Diese Tabellen sind miteinander verknüpft, sodass Benutzer Aufgaben erstellen und diese in Kategorien und Unterkategorien organisieren können.

\begin{lstlisting}[language=Python]

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextIndex", "fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int        @id @default(autoincrement())
  email     String     @unique
  username  String     @unique 
  password  String?
  role      String     @default("USER")
  exercises Exercise[]
  retry     Int        @default(0)
  retryExp  DateTime?  
}

model Exercise {
  id            Int         @id @default(autoincrement())
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  summary       String? // Optional, kann null sein
  content       String
  solution      String
  language      String      @default("Deutsch")
  difficulty    Int         @default(1)
  authorId      Int         @default(1)
  author        User        @relation(fields: [authorId], references: [id])
  categoryId    Int         @default(1)
  categories    Category    @relation(fields: [categoryId], references: [id])
  subcategoryId Int @default(1)
  subcategories Subcategory @relation(fields: [subcategoryId], references: [id])
}

model Category {
  id            Int           @id @default(autoincrement())
  name          String
  subcategories Subcategory[]
  exercises     Exercise[]
}

model Subcategory {
  id         Int        @id @default(autoincrement())
  name       String
  categoryId Int
  category   Category   @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  exercises  Exercise[]
}

\end{lstlisting}




\subsubsection{Tabelle \texttt{User}}

Die Tabelle \texttt{User} speichert die Informationen der Benutzer. Jeder Benutzer hat eine eindeutige ID sowie eine E-Mail-Adresse und einen Benutzernamen. Optional kann ein Passwort gespeichert werden. Benutzer können eine Rolle besitzen (standardmäßig \texttt{USER}), die ihre Berechtigungen festlegt. Zusätzlich verwaltet die Tabelle die Aufgaben, die ein Benutzer erstellt hat.

\begin{itemize}
  \item \texttt{id}: Primärschlüssel, automatisch inkrementiert.
  \item \texttt{email}: Eindeutige E-Mail-Adresse des Benutzers.
  \item \texttt{username}: Eindeutiger Benutzername.
  \item \texttt{password}: Optionales Passwortfeld, kann null sein.
  \item \texttt{role}: Rolle des Benutzers (standardmäßig \texttt{USER}).
  \item \texttt{exercises}: Beziehung zur Tabelle \texttt{Exercise}. Verknüpfung zu den von diesem Benutzer erstellten Aufgaben, dies ist eine \texttt{1:n}-Beziehung da der Benutzer mehrer Aufgaben erstellen kann
  \item \texttt{retry}: Anzahl der fehlgeschlagenen Anmeldeversuche.
  \item \texttt{retryExp}: Zeitpunkt, ab dem der Benutzer nach mehreren Fehlversuchen erneut versuchen kann, sich anzumelden.
\end{itemize}

\subsubsection{Tabelle \texttt{Exercise}}

Die Tabelle \texttt{Exercise} speichert die einzelnen Mathematikaufgaben, die von Benutzern erstellt werden. Jede Aufgabe enthält Informationen wie den Inhalt, die Lösung, die Sprache und den Schwierigkeitsgrad. Jede Aufgabe ist einem Benutzer (dem Autor), einer Kategorie und einer Unterkategorie zugeordnet.

\begin{itemize}
  \item \texttt{id}: Primärschlüssel, automatisch inkrementiert.
  \item \texttt{createdAt}: Erstellungsdatum der Aufgabe, standardmäßig die aktuelle Zeit.
  \item \texttt{updatedAt}: Automatisch aktualisiertes Datum, wenn die Aufgabe geändert wird.
  \item \texttt{summary}: Eine optionale Zusammenfassung der Aufgabe.
  \item \texttt{content}: Der eigentliche Inhalt der Aufgabe.
  \item \texttt{solution}: Die Lösung der Aufgabe.
  \item \texttt{language}: Sprache der Aufgabe (standardmäßig \texttt{Deutsch}).
  \item \texttt{difficulty}: Schwierigkeitsgrad der Aufgabe (standardmäßig 1).
  \item \texttt{authorId}: Fremdschlüssel, der den Benutzer referenziert, der die Aufgabe erstellt hat.
   \item \texttt{author}: Beziehung zur Tabelle \texttt{User}, der die Aufgabe erstellt hat. Diese Beziehung ist eine \texttt{1:n}-Beziehung, da ein Benutzer mehrere Aufgaben erstellen kann.
  \item \texttt{categoryId}: Fremdschlüssel, der die Kategorie referenziert, zu der die Aufgabe gehört.
  
\item \texttt{categories}: Beziehung zur Tabelle \texttt{Category}. Diese Beziehung ist eine \texttt{n:1}-Beziehung, da jede Aufgabe genau einer Kategorie zugeordnet ist, aber eine Kategorie mehrere Aufgaben enthalten kann.
  \item \texttt{subcategoryId}: Fremdschlüssel, der die Unterkategorie referenziert, zu der die Aufgabe gehört.
    \item \texttt{subcategories}: Beziehung zur Tabelle \texttt{Subcategory}. Diese Beziehung ist ebenfalls eine \texttt{n:1}-Beziehung, da jede Aufgabe genau einer Unterkategorie zugeordnet ist, aber eine Unterkategorie mehrere Aufgaben umfassen kann.
\end{itemize}

\subsubsection{Tabelle \texttt{Category}}

Die Tabelle \texttt{Category} enthält Informationen über die Hauptkategorien, denen Aufgaben zugeordnet werden können. Eine Kategorie kann mehrere Unterkategorien und Aufgaben beinhalten.

\begin{itemize}
  \item \texttt{id}: Primärschlüssel, automatisch inkrementiert.
  \item \texttt{name}: Name der Kategorie.
   \item \texttt{subcategories}: Beziehung zur Tabelle \texttt{Subcategory}. Diese Beziehung ist eine \texttt{1:n}-Beziehung, da eine Kategorie mehrere Unterkategorien enthalten kann, aber jede Unterkategorie nur zu einer Kategorie gehört.
  \item \texttt{exercises}: Beziehung zur Tabelle \texttt{Exercise}. Diese Beziehung ist ebenfalls eine \texttt{1:n}-Beziehung, da eine Kategorie mehrere Aufgaben enthalten kann, aber jede Aufgabe nur zu einer Kategorie gehört.
\end{itemize}

\subsubsection{Tabelle \texttt{Subcategory}}

Die Tabelle \texttt{Subcategory} speichert Informationen über die Unterkategorien, die einer übergeordneten Kategorie zugeordnet sind. Jede Unterkategorie kann mehrere Aufgaben enthalten.

\begin{itemize}
  \item \texttt{id}: Primärschlüssel, automatisch inkrementiert.
  \item \texttt{name}: Name der Unterkategorie.
  \item \texttt{categoryId}: Fremdschlüssel, der die übergeordnete Kategorie referenziert.
 \item \texttt{category}: Beziehung zur Tabelle \texttt{Category}. Diese Beziehung ist eine \texttt{n:1}-Beziehung, da jede Unterkategorie zu genau einer Kategorie gehört, aber eine Kategorie mehrere Unterkategorien enthalten kann.Beziehung zur übergeordneten Kategorie, bei deren Löschung die Unterkategorie ebenfalls gelöscht wird (Cascade-Löschung).
 
   \item \texttt{exercises}: Beziehung zur Tabelle \texttt{Exercise}. Diese Beziehung ist eine \texttt{1:n}-Beziehung, da eine Unterkategorie mehrere Aufgaben enthalten kann, aber jede Aufgabe nur zu einer Unterkategorie gehört.
\end{itemize}

\subsubsection{Zusammenfassung}

Das beschriebene Datenbankmodell ermöglicht eine klare und logische Strukturierung von Benutzern, Aufgaben, Kategorien und Unterkategorien. Mithilfe von \texttt{Prisma} ORM und \texttt{PostgreSQL} als Datenbank wird sichergestellt, dass die Anwendung skalierbar und effizient auf große Datenmengen zugreifen kann. Jede Tabelle ist durch eindeutige Beziehungen verknüpft, was eine einfache Verwaltung der Daten und eine effiziente Abfrage ermöglicht.


Die Datenbankstruktur unterstützt umfassende Interaktionen zwischen Benutzern, ihren Aufgaben sowie die Kategorisierung von Aufgaben.




\section{Methodik}
Unser Projekt folgte einem strukturierten Softwareentwicklungsprozess, der in mehrere Phasen unterteilt war. Wir begannen mit einer detaillierten Anforderungsanalyse und der Definition von Use Cases, um die Bedürfnisse der Endbenutzer zu verstehen.

\subsection{Backend-Entwicklung}
Die Implementierung von CRUD-Operationen und Authentifizierungssystemen stellte sicher, dass die Anwendung sicher und robust ist.

CRUD- und HTTP-Operationen:

CRUD steht für Create, Read, Update, Delete und bezieht sich auf die vier grundlegenden Operationen, die in vielen Anwendungen zur Interaktion mit Datenbanken oder Datenspeichern verwendet werden. Die Implementierung von CRUD-Operationen ermöglicht es Benutzern (oder Systemen), Daten zu erstellen, abzurufen (lesen), zu aktualisieren und zu löschen.

In einer Webanwendung werden CRUD-Operationen typischerweise über das Backend realisiert, wobei das Frontend (die Benutzeroberfläche) Anfragen an das Backend sendet, um Daten zu erstellen, abzurufen, zu aktualisieren oder zu löschen. Das Backend interagiert dann mit der Datenbank, um die angeforderten Aktionen durchzuführen und das Ergebnis (z.B. die abgerufenen Daten oder eine Bestätigung der Aktion) an das Frontend zurückzusenden, wo es dem Benutzer angezeigt wird.

Für das Backend, das oft eine API bereitstellt, können diese Operationen spezifischen Endpunkten entsprechen, z.B.:

•	GET /api/users	für das Abrufen von Benutzern (Read)

•	POST /api/user	für das Erstellen eines neuen Benutzers (Create)

•	PUT /api/user	für das Aktualisieren eines spezifischen Benutzers (Update)

•	POST /api/ex	für das Erstellen einer neuen Aufgabe (Create)

•	GET /api/ex	für das Abrufen von Aufgaben (Read)

•	PUT /api/ex/:id	für das Aktualisieren einer spezifischen Aufgabe (Update)

•	DELETE /api/ex/:id 	für das Löschen einer Aufgabe (Delete)

•	GET /api/ex/search/:serachText	für das Abrufen von Aufgaben nach Suchbegriffen (Read)

•	GET /api/ex/category/:category	für das Abrufen von Aufgaben nach Kategorien (Read)

•	GET /api/ex/:id	für das Abrufen einer spezifischen Aufgabe (Read)

•	POST /api/download/ 	für das Herunterladen der spezifischen Aufgabe im Warenkorb (Download)


\subsection{Frontend-Entwicklung}
Wir entwickelten mehrere UI-Komponenten, die es den Nutzern ermöglichen, Aufgaben einfach zu erstellen, zu durchsuchen und zu verwalten.
\subsection{Authentifizierug und Autorisierung}
Argon2 nimmt als Eingabe das Passwort des Benutzers, einen Salz (eine zufällig generierte Zeichenfolge, die jedem Passwort-Hash hinzugefügt wird, um die Einzigartigkeit zu gewährleisten), und mehrere Parameter, die die Komplexität des Hashing-Vorgangs steuern (wie Speicherbedarf, Rechenzeit und Parallelität).Basierend auf diesen Eingaben führt Argon2 eine Reihe von komplexen, rechenintensiven Operationen durch. Diese Operationen sind so gestaltet, dass sie sowohl eine hohe Menge an CPU-Ressourcen als auch Speicher benötigen. Dies macht es sehr schwierig für Angreifer, Passwörter zu erraten oder Brute-Force-Angriffe durchzuführen, selbst wenn sie über leistungsfähige Hardware verfügen.

Das Ergebnis des Prozesses ist ein Passwort-Hash, der in der Datenbank gespeichert wird. Da der gleiche Prozess (mit dem gleichen Salz und denselben Parametern) immer denselben Hash erzeugt, kann das System das vom Benutzer bei der Anmeldung eingegebene Passwort überprüfen, ohne das eigentliche Passwort kennen oder speichern zu müssen. Sicherheit gegen Brute-Force-Angriffe: Die rechen- und speicherintensive Natur von Argon2 macht es teuer und zeitaufwändig, Hashes zu knacken. Dies schützt gegen Angriffe, die darauf abzielen, Passwörter durch Ausprobieren vieler möglicher Kombinationen (Brute-Force) zu erraten.

\subsection{Testing und Qualitätssicherung: }
Wir führten umfangreiche Tests durch, einschließlich Unit-Tests und Benutzerakzeptanztests, um sicherzustellen, dass die Anwendung den Erwartungen entspricht.


\subsection{Deployment und Inbetriebnahme: }
Nach Abschluss der Entwicklungsarbeiten wurde die Anwendung auf einer geeigneten Hosting-Plattform bereitgestellt und auf ihre Funktionalität in der Produktionsumgebung überprüft.


\section{Ergbenisse}
\subsection{Allgemeines}

Die entwickelte Webanwendung bietet Mathematiklehrern eine Plattform, auf der sie Aufgaben erstellen, durchsuchen, kommentieren und verwalten können. Zu den wichtigsten Funktionen gehören:

•	Aufgaben erstellen und verwalten: Lehrer können neue Aufgaben zur Datenbank hinzufügen und bestehende Aufgaben bearbeiten oder löschen.

•	Aufgabensuche: Die Suchfunktion ermöglicht es den Nutzern, spezifische Aufgaben nach Stichworten oder Kategorien zu finden.

•	Warenkorbsystem: Lehrer können ausgewählte Aufgaben in einem Warenkorb sammeln und daraus Aufgabenblätter erstellen.

Die Anwendung wurde erfolgreich implementiert und erfüllt die gestellten Anforderungen.

\subsection{Die Komponentenübersicht}

\begin{itemize}


\item Aufgabendetails (Exercise Details):

Eine Detailansicht (AufgDetails) für jede Aufgabe, die Informationen wie Aufgabentext, Lösung, Kommentare und Kategoriezugehörigkeit enthält. Benutzer können Aufgaben kommentieren und in den Warenkorb legen.

\item Suchergebnisse (Search Results):

Komponenten für die Anzeige von Suchergebnissen, einschließlich Suchkarten (SearchCard), die einzelne Aufgaben darstellen, und einer Listenansicht (CardListSearch), die eine Sammlung von Suchkarten enthält. Ein spezieller Warenkorb für die Suche (SearchKorb) sammelt gesuchte Aufgaben für spätere Aktionen.

\item Warenkorb (Warenkorb):

Beinhaltet Komponenten zum Verwalten der ausgewählten Aufgaben, wie WarenCard für einzelne Aufgaben im Warenkorb und CardListWaren für die Gesamtansicht des Warenkorbs. Der WarenKorb selbst ist die Hauptkomponente, die den Nutzern die Interaktion mit dem Warenkorb ermöglicht, einschließlich der Überprüfung und Finalisierung ihrer Auswahl.

\item Aufgaben hinzufügen (Add Exercises):

Die ExForm-Komponente ermöglicht das Erstellen neuer Aufgaben. Sie umfasst Formularfelder für die Eingabe von Titel, Inhalt, Lösung und optionalen Kategorien. Über eine API-Anfrage (askServer(/api/ex, "POST", ex)) werden die Daten an das Backend gesendet und die Aufgabe wird der Datenbank hinzugefügt.

\item Aufgaben finden (Find Exercises):

Dieser Bereich umfasst mehrere Komponenten, die unterschiedliche Methoden zur Aufgabensuche anbieten, darunter FindExByCategory für kategoriebasierte Suche, FindExByIdFromServer für die direkte Abfrage einer Aufgabe über ihre ID und FindExBySearchText für textbasierte Suchanfragen.

\item Benutzerregistrierung und -anmeldung (User Registration/Login):

Eine Form-Komponente unterstützt die Registrierung neuer Benutzer und die Anmeldung bestehender Benutzer durch Übermittlung ihrer Anmeldeinformationen an das Backend (askServer(/api/user, "POST", user)). Authentifizierungsdaten werden überprüft, um Zugang zu geschützten Bereichen der Anwendung zu gewähren.

\item Navigation (Navigation):

Die Menu-Komponente stellt die Hauptnavigation der Anwendung bereit und ermöglicht den Zugriff auf die verschiedenen Seiten und Funktionen der App, darunter die Startseite (/), das Hinzufügen von Aufgaben (/add), das Finden von Aufgaben (/find), den Warenkorb (/warenkorb) und die Detailansicht einer spezifischen Aufgabe (/:id).

\item Seiten (Pages):

Definiert die Struktur der Anwendung und beinhaltet Seitenkomponenten wie User für die Benutzerregistrierung und -anmeldung, AddExercise für das Hinzufügen neuer Aufgaben, FindExercise für die Aufgabensuche, Letzte Suchresultate für das Anzeigen der zuletzt gesuchten Aufgaben und WarenKorb für die Ansicht und Verwaltung des Warenkorbs.

\end{itemize}


\section{Fazit/Diskussion}
Unsere Untersuchung hat gezeigt, dass die gewählten Technologien geeignet waren, um eine benutzerfreundliche und effiziente Webanwendung zu entwickeln. Die Hypothese, dass eine solche Anwendung den Bedürfnissen von Mathematiklehrern gerecht wird, konnte bestätigt werden. Allerdings stießen wir auf einige Herausforderungen, insbesondere im Bereich der Performance-Optimierung und der Benutzerfreundlichkeit, die in zukünftigen Projekten weiter untersucht werden sollten.

Zukünftige Arbeiten könnten sich darauf konzentrieren, die Anwendung durch zusätzliche Funktionen wie die Integration von KI-gestützten Aufgabenvorschlägen zu erweitern.

\section{Schlusswort}
Die Arbeit an diesem Projekt war eine wertvolle Erfahrung, die uns sowohl im Bereich der Softwareentwicklung als auch in der Projektorganisation weitergebracht hat. Die Erreichung unserer Ziele hat unsere Erwartungen erfüllt, und wir hoffen, dass unsere Anwendung einen praktischen Beitrag zur Verbesserung des Mathematikunterrichts leisten kann.

\newpage
   
  
% Hier beginnt der Anhang
\appendix
\section{Anhang}
\newpage





\section{Bilderverzeichnis}
\listoffigures



\newpage
\section{Literaturverzeichnis}

\begin{thebibliography}{1} % Hier werden die einzelnen Quellen abgelegt. Die Quellen werden mit dem Befehl \bibitem kreiert. Der Ausdruck in geschweiften Klammern ist die interne Bezeichnung, die man verwendet, um daraus im Text zu zitieren


\bibitem{buch1} Nachname, Vorname {\em Titel eines ersten Buchs} Jahr: Verlag.

\bibitem{buch2} Nachname, Vorname {\em Titel eines zweiten Buchs} Jahr: Verlag.

% Diese Quelle wird im Text zitiert, wenn man den Befehl \cite{sw16} eingibt.


\end{thebibliography}








\end{document}